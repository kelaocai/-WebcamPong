<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title> Webcam Pong by kelaocai</title>
  <style>
    body {
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column; /* å‚ç›´å¸ƒå±€ï¼Œæ ‡é¢˜åœ¨ä¸Š */
      align-items: center;
      height: 100vh;
      color: white;
      font-family: Arial, sans-serif;
    }
    h1 {
      margin: 20px 0 10px 0;
      font-size: 36px;
      color: #00ff88;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
    }
    .container {
      display: flex;
      flex-direction: row;
      align-items: center;
    }
    #gameCanvas { background: #111; }
    #videoCanvas { background: #000; margin-left: 10px; }
    
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #00ff88;
      color: white;
      font-size: 14px;
      min-width: 200px;
    }
    
    .controls h3 {
      margin: 0 0 10px 0;
      color: #00ff88;
      font-size: 16px;
    }
    
    .control-group {
      margin-bottom: 10px;
    }
    
    .control-group label {
      display: block;
      margin-bottom: 5px;
      color: #ccc;
    }
    
    .control-group input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }
    
    .control-group select {
      width: 100%;
      padding: 3px;
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 3px;
    }
  </style>
</head>
<body>
<h1>Webcam Pong </h1>

<div class="controls">
  <h3>âš™ï¸ æ¸¸æˆè®¾ç½®</h3>
  <div class="control-group">
    <label>AI éš¾åº¦ï¼š<span id="difficultyValue">0.8</span></label>
    <input type="range" id="difficultySlider" min="0.3" max="1.0" step="0.1" value="0.8">
  </div>
  <div class="control-group">
    <label>çƒé€Ÿï¼š<span id="speedValue">4</span></label>
    <input type="range" id="speedSlider" min="2" max="8" step="1" value="4">
  </div>
  <div class="control-group">
    <label>æ§åˆ¶çµæ•åº¦ï¼š<span id="sensitivityValue">0.3</span></label>
    <input type="range" id="sensitivitySlider" min="0.1" max="0.5" step="0.05" value="0.3">
  </div>
  <div class="control-group">
    <label>éŸ³æ•ˆ</label>
    <select id="soundToggle">
      <option value="true">å¼€å¯</option>
      <option value="false">å…³é—­</option>
    </select>
  </div>
</div>

<div class="container">
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <canvas id="videoCanvas" width="270" height="480"></canvas> <!-- 9:16 æ¯”ä¾‹ -->
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

<script>
  const gameCanvas = document.getElementById('gameCanvas');
  const gameCtx = gameCanvas.getContext('2d');

  const videoCanvas = document.getElementById('videoCanvas');
  const videoCtx = videoCanvas.getContext('2d');

  let leftPaddleY = gameCanvas.height/2 - 40;
  let rightPaddleY = gameCanvas.height/2 - 40;
  let paddleHeight = 80, paddleWidth = 10;
  let ballX = gameCanvas.width/2, ballY = gameCanvas.height/2;
  let ballDX = 4, ballDY = 2, ballSize = 10;

  let leftScore = 0, rightScore = 0;
  let video;
  let aiDifficulty = 0.8; // AI éš¾åº¦ (0.1-1.0)
  let aiReactionTime = 0; // AI ååº”å»¶è¿Ÿå¸§æ•°
  let particles = []; // ç²’å­ç³»ç»Ÿ
  let gameSpeed = 4; // æ¸¸æˆé€Ÿåº¦
  let soundEnabled = true; // éŸ³æ•ˆå¼€å…³
  
  // éŸ³æ•ˆç³»ç»Ÿ
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  function playBeep(frequency, duration) {
    if (!soundEnabled) return;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = frequency;
    oscillator.type = 'sine';
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  }
  
  // è®¾ç½®æ§åˆ¶
  document.addEventListener('DOMContentLoaded', function() {
    const difficultySlider = document.getElementById('difficultySlider');
    const speedSlider = document.getElementById('speedSlider');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const soundToggle = document.getElementById('soundToggle');
    
    difficultySlider.addEventListener('input', function() {
      aiDifficulty = parseFloat(this.value);
      document.getElementById('difficultyValue').textContent = aiDifficulty;
    });
    
    speedSlider.addEventListener('input', function() {
      gameSpeed = parseInt(this.value);
      document.getElementById('speedValue').textContent = gameSpeed;
    });
    
    sensitivitySlider.addEventListener('input', function() {
      alpha = parseFloat(this.value);
      document.getElementById('sensitivityValue').textContent = alpha;
    });
    
    soundToggle.addEventListener('change', function() {
      soundEnabled = this.value === 'true';
    });
  });

  let smoothRightPaddleY = gameCanvas.height / 2 - paddleHeight / 2;
  let alpha = 0.3; // é™ä½é»˜è®¤å¹³æ»‘ç³»æ•°ï¼Œæé«˜ç¨³å®šæ€§
  let handCenterX = 0; // æ‰‹éƒ¨æ°´å¹³ä¸­å¿ƒä½ç½®
  let handVelocity = 0; // æ‰‹éƒ¨ç§»åŠ¨é€Ÿåº¦
  let lastHandY = 0; // ä¸Šä¸€å¸§æ‰‹éƒ¨ä½ç½®
  
  // å¢å¼ºçš„å¹³æ»‘ç³»ç»Ÿ
  let handPositionHistory = []; // æ‰‹éƒ¨ä½ç½®å†å²è®°å½•
  let maxHistoryLength = 8; // å†å²è®°å½•é•¿åº¦
  let smoothedHandY = 0; // é¢å¤–å¹³æ»‘çš„æ‰‹éƒ¨ä½ç½®
  let velocitySmooth = 0; // å¹³æ»‘çš„é€Ÿåº¦

  async function initCamera() {
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.width = 640;
    video.height = 480;
    await navigator.mediaDevices.getUserMedia({video: true}).then(stream => {
      video.srcObject = stream;
    });
    return new Promise(resolve => {
      video.onloadedmetadata = () => resolve(video);
    });
  }

  // ç²’å­ç±»
  class Particle {
    constructor(x, y, color = 'white') {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 10;
      this.vy = (Math.random() - 0.5) * 10;
      this.life = 30;
      this.maxLife = 30;
      this.color = color;
    }
    
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= 0.98;
      this.vy *= 0.98;
      this.life--;
    }
    
    draw(ctx) {
      const alpha = this.life / this.maxLife;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    isDead() {
      return this.life <= 0;
    }
  }

  function createParticles(x, y, color, count = 8) {
    for (let i = 0; i < count; i++) {
      particles.push(new Particle(x, y, color));
    }
  }

  // æ•°æ®ç¨³å®šæ€§æ£€æµ‹å’Œå¹³æ»‘å¤„ç†
  function smoothHandPosition(newY) {
    // æ·»åŠ åˆ°å†å²è®°å½•
    handPositionHistory.push(newY);
    if (handPositionHistory.length > maxHistoryLength) {
      handPositionHistory.shift();
    }
    
    // å¦‚æœå†å²è®°å½•ä¸è¶³ï¼Œç›´æ¥è¿”å›æ–°å€¼
    if (handPositionHistory.length < 3) {
      return newY;
    }
    
    // è®¡ç®—ç§»åŠ¨å¹³å‡å€¼
    const average = handPositionHistory.reduce((sum, val) => sum + val, 0) / handPositionHistory.length;
    
    // æ£€æµ‹å¼‚å¸¸å€¼ï¼ˆç›¸æ¯”å¹³å‡å€¼å˜åŒ–è¿‡å¤§ï¼‰
    const threshold = gameCanvas.height * 0.1; // 10% çš„å˜åŒ–é˜ˆå€¼
    if (Math.abs(newY - average) > threshold) {
      // å¦‚æœæ˜¯å¼‚å¸¸å€¼ï¼Œä½¿ç”¨å†å²å¹³å‡å€¼çš„åŠ æƒç»“æœ
      return average * 0.8 + newY * 0.2;
    }
    
    // ä½¿ç”¨åŠ æƒå¹³å‡ï¼Œæœ€è¿‘çš„å€¼æƒé‡æ›´é«˜
    let weightedSum = 0;
    let totalWeight = 0;
    for (let i = 0; i < handPositionHistory.length; i++) {
      const weight = (i + 1) / handPositionHistory.length; // è¶Šæ–°çš„æƒé‡è¶Šå¤§
      weightedSum += handPositionHistory[i] * weight;
      totalWeight += weight;
    }
    
    return weightedSum / totalWeight;
  }

  function drawSkeleton(prediction, cropX, cropY, cropWidth, cropHeight) {
    const connections = [
      ['thumb', 'indexFinger'],
      ['indexFinger', 'middleFinger'],
      ['middleFinger', 'ringFinger'],
      ['ringFinger', 'pinky'],
      ['thumb', 'palmBase'],
      ['indexFinger', 'palmBase'],
      ['middleFinger', 'palmBase'],
      ['ringFinger', 'palmBase'],
      ['pinky', 'palmBase']
    ];

    for (let finger of Object.keys(prediction.annotations)) {
      const points = prediction.annotations[finger];
      for (let i = 0; i < points.length - 1; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[i + 1];
        videoCtx.beginPath();
        videoCtx.moveTo((x1 - cropX) * (videoCanvas.width / cropWidth),
                (y1 - cropY) * (videoCanvas.height / cropHeight));
        videoCtx.lineTo((x2 - cropX) * (videoCanvas.width / cropWidth),
                (y2 - cropY) * (videoCanvas.height / cropHeight));
        videoCtx.strokeStyle = 'lime';
        videoCtx.lineWidth = 2;
        videoCtx.stroke();
      }
    }

    for (let conn of connections) {
      const start = prediction.annotations[conn[0]][0];
      const end = prediction.annotations[conn[1]][0];
      videoCtx.beginPath();
      videoCtx.moveTo((start[0] - cropX) * (videoCanvas.width / cropWidth),
              (start[1] - cropY) * (videoCanvas.height / cropHeight));
      videoCtx.lineTo((end[0] - cropX) * (videoCanvas.width / cropWidth),
              (end[1] - cropY) * (videoCanvas.height / cropHeight));
      videoCtx.strokeStyle = 'lime';
      videoCtx.lineWidth = 2;
      videoCtx.stroke();
    }
  }

  async function main() {
    await initCamera();
    const model = await handpose.load();

    async function gameLoop() {
      const vw = video.videoWidth;
      const vh = video.videoHeight;

      let predictions = await model.estimateHands(video, true);

      if (predictions.length > 0) {
        const allX = predictions[0].landmarks.map(p => p[0]);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        handCenterX = (minX + maxX) / 2;

        const fingerY = predictions[0].annotations.indexFinger[3][1];
        const normalizedY = Math.max(0, Math.min(1, (fingerY - 0) / vh));
        const rawHandY = normalizedY * gameCanvas.height;
        
        // ä½¿ç”¨æ–°çš„å¹³æ»‘ç®—æ³•å¤„ç†æ‰‹éƒ¨ä½ç½®
        const smoothedY = smoothHandPosition(rawHandY);
        
        // è®¡ç®—å¹³æ»‘çš„é€Ÿåº¦
        const currentVelocity = smoothedY - smoothedHandY;
        velocitySmooth = velocitySmooth * 0.7 + currentVelocity * 0.3;
        smoothedHandY = smoothedY;
        
        // å‡å°‘é¢„æµ‹æ€§ç§»åŠ¨çš„å¼ºåº¦ï¼Œé¿å…è¿‡åº¦æ•æ„Ÿ
        const predictiveOffset = velocitySmooth * 0.5; // é™ä½é¢„æµ‹å¼ºåº¦
        const finalY = smoothedY + predictiveOffset;
        const mappedY = finalY - paddleHeight / 2;
        const targetY = Math.max(0, Math.min(gameCanvas.height - paddleHeight, mappedY));

        // ä½¿ç”¨å›ºå®šçš„å¹³æ»‘ç³»æ•°ï¼Œé¿å…åŠ¨æ€å˜åŒ–é€ æˆçš„æŠ–åŠ¨
        const fixedAlpha = Math.min(alpha, 0.4); // é™åˆ¶æœ€å¤§å¹³æ»‘ç³»æ•°
        
        // æ·»åŠ æ­»åŒºæœºåˆ¶ï¼Œå‡å°‘å¾®å°ç§»åŠ¨é€ æˆçš„æŠ–åŠ¨
        const deadZone = 3; // åƒç´ æ­»åŒº
        const targetDiff = targetY - smoothRightPaddleY;
        if (Math.abs(targetDiff) > deadZone) {
          smoothRightPaddleY = fixedAlpha * targetY + (1 - fixedAlpha) * smoothRightPaddleY;
        }
        
        rightPaddleY = smoothRightPaddleY;
      } else {
        // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œé€æ¸å‡å°‘é€Ÿåº¦
        velocitySmooth *= 0.9;
      }

      const targetAspect = 9/16;
      let cropHeight = vh;
      let cropWidth = cropHeight * targetAspect;
      let cropX = Math.max(0, Math.min(vw - cropWidth, handCenterX - cropWidth / 2));
      const cropY = 0;

      videoCtx.drawImage(video, cropX, cropY, cropWidth, cropHeight,
              0, 0, videoCanvas.width, videoCanvas.height);

      // ç»˜åˆ¶æ‰‹åŠ¿è¯†åˆ«åŒºåŸŸå’Œæç¤º
      const boxMargin = 40;
      const boxX = 20;
      const boxY = boxMargin;
      const boxWidth = videoCanvas.width - 40;
      const boxHeight = videoCanvas.height - boxMargin * 2;
      
      // æ´»è·ƒåŒºåŸŸèƒŒæ™¯
      videoCtx.fillStyle = 'rgba(0, 255, 136, 0.05)';
      videoCtx.fillRect(boxX, boxY, boxWidth, boxHeight);
      
      // è¾¹æ¡†åŠ¨ç”»æ•ˆæœ
      const time = Date.now() * 0.003;
      const borderIntensity = 0.7 + 0.3 * Math.sin(time);
      videoCtx.strokeStyle = `rgba(0, 255, 136, ${borderIntensity})`;
      videoCtx.lineWidth = 3;
      videoCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);
      
      // è§’è½è£…é¥°
      const cornerSize = 20;
      videoCtx.strokeStyle = 'lime';
      videoCtx.lineWidth = 4;
      // å·¦ä¸Šè§’
      videoCtx.beginPath();
      videoCtx.moveTo(boxX, boxY + cornerSize);
      videoCtx.lineTo(boxX, boxY);
      videoCtx.lineTo(boxX + cornerSize, boxY);
      videoCtx.stroke();
      // å³ä¸Šè§’
      videoCtx.beginPath();
      videoCtx.moveTo(boxX + boxWidth - cornerSize, boxY);
      videoCtx.lineTo(boxX + boxWidth, boxY);
      videoCtx.lineTo(boxX + boxWidth, boxY + cornerSize);
      videoCtx.stroke();
      // å·¦ä¸‹è§’
      videoCtx.beginPath();
      videoCtx.moveTo(boxX, boxY + boxHeight - cornerSize);
      videoCtx.lineTo(boxX, boxY + boxHeight);
      videoCtx.lineTo(boxX + cornerSize, boxY + boxHeight);
      videoCtx.stroke();
      // å³ä¸‹è§’
      videoCtx.beginPath();
      videoCtx.moveTo(boxX + boxWidth - cornerSize, boxY + boxHeight);
      videoCtx.lineTo(boxX + boxWidth, boxY + boxHeight);
      videoCtx.lineTo(boxX + boxWidth, boxY + boxHeight - cornerSize);
      videoCtx.stroke();
      
      // æ–‡å­—æç¤º
      if (predictions.length === 0) {
        videoCtx.fillStyle = 'rgba(0, 255, 136, 0.9)';
        videoCtx.font = 'bold 16px Arial';
        videoCtx.textAlign = 'center';
        videoCtx.fillText('å°†æ‰‹æ”¾å…¥ç»¿è‰²åŒºåŸŸ', videoCanvas.width / 2, boxY + boxHeight / 2 - 10);
        videoCtx.font = '14px Arial';
        videoCtx.fillText('ğŸ‘‹ ä¼¸å‡ºé£ŸæŒ‡æ§åˆ¶çƒæ‹', videoCanvas.width / 2, boxY + boxHeight / 2 + 15);
      } else {
        // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
        videoCtx.fillStyle = 'rgba(0, 255, 0, 0.8)';
        videoCtx.font = 'bold 12px Arial';
        videoCtx.textAlign = 'center';
        videoCtx.fillText('âœ“ æ‰‹åŠ¿è¯†åˆ«ä¸­', videoCanvas.width / 2, boxY - 5);
      }

      if (predictions.length > 0) {
        drawSkeleton(predictions[0], cropX, cropY, cropWidth, cropHeight);
        predictions[0].landmarks.forEach(point => {
          const px = (point[0] - cropX) * (videoCanvas.width / cropWidth);
          const py = (point[1] - cropY) * (videoCanvas.height / cropHeight);
          videoCtx.beginPath();
          videoCtx.arc(px, py, 3, 0, 2 * Math.PI);
          videoCtx.fillStyle = 'red';
          videoCtx.fill();
        });
      }

      updateBall();
      drawGame();
      requestAnimationFrame(gameLoop);
    }

    function updateBall() {
      ballX += ballDX;
      ballY += ballDY;
      if (ballY < 0 || ballY > gameCanvas.height - ballSize) {
        ballDY = -ballDY;
        createParticles(ballX + ballSize/2, ballY < 0 ? 0 : gameCanvas.height, '#00ff88', 6);
        playBeep(800, 0.1);
      }
      if (ballX < paddleWidth && ballY > leftPaddleY && ballY < leftPaddleY + paddleHeight) {
        ballDX = -ballDX;
        // æ·»åŠ è§’åº¦å˜åŒ–
        ballDY += (ballY - (leftPaddleY + paddleHeight/2)) * 0.1;
        createParticles(ballX, ballY + ballSize/2, '#ff4444', 10);
        playBeep(600, 0.15);
      }
      if (ballX > gameCanvas.width - paddleWidth - ballSize && ballY > rightPaddleY && ballY < rightPaddleY + paddleHeight) {
        ballDX = -ballDX;
        // æ·»åŠ è§’åº¦å˜åŒ–
        ballDY += (ballY - (rightPaddleY + paddleHeight/2)) * 0.1;
        createParticles(ballX + ballSize, ballY + ballSize/2, '#4444ff', 10);
        playBeep(600, 0.15);
      }

      // æ”¹è¿›çš„AIé€»è¾‘
      if (ballDX < 0 && ballX < gameCanvas.width * 0.6) { // çƒå‘å·¦ç§»åŠ¨ä¸”åœ¨å·¦åŠåœº
        // é¢„æµ‹çƒåˆ°è¾¾å·¦è¾¹ç•Œçš„Yä½ç½®
        const timeToReach = Math.abs(ballX - paddleWidth) / Math.abs(ballDX);
        let predictedY = ballY + ballDY * timeToReach;
        
        // å¤„ç†åå¼¹
        while (predictedY < 0 || predictedY > gameCanvas.height) {
          if (predictedY < 0) predictedY = -predictedY;
          if (predictedY > gameCanvas.height) predictedY = 2 * gameCanvas.height - predictedY;
        }
        
        const targetY = predictedY - paddleHeight / 2;
        const clampedTargetY = Math.max(0, Math.min(gameCanvas.height - paddleHeight, targetY));
        
        // æ ¹æ®éš¾åº¦è°ƒæ•´ AI ç§»åŠ¨é€Ÿåº¦å’Œå‡†ç¡®æ€§
        const aiSpeed = 2 + aiDifficulty * 3;
        const accuracy = 0.7 + aiDifficulty * 0.3;
        const randomOffset = (Math.random() - 0.5) * 20 * (1 - accuracy);
        
        const finalTargetY = clampedTargetY + randomOffset;
        
        if (Math.abs(leftPaddleY + paddleHeight/2 - predictedY) > 10) {
          if (leftPaddleY + paddleHeight/2 < finalTargetY) {
            leftPaddleY += aiSpeed;
          } else {
            leftPaddleY -= aiSpeed;
          }
        }
        
        leftPaddleY = Math.max(0, Math.min(gameCanvas.height - paddleHeight, leftPaddleY));
      }

      if (ballX < 0) { 
        rightScore++; 
        resetBall(); 
        playBeep(300, 0.3);
        createParticles(0, ballY, '#ffff00', 15);
      }
      if (ballX > gameCanvas.width) { 
        leftScore++; 
        resetBall(); 
        playBeep(300, 0.3);
        createParticles(gameCanvas.width, ballY, '#ffff00', 15);
      }
      
      // æ›´æ–°ç²’å­
      particles = particles.filter(particle => {
        particle.update();
        return !particle.isDead();
      });
    }

    function drawGame() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      gameCtx.fillStyle = 'white';
      gameCtx.fillRect(0, leftPaddleY, paddleWidth, paddleHeight);
      gameCtx.fillRect(gameCanvas.width - paddleWidth, rightPaddleY, paddleWidth, paddleHeight);
      
      // ç»˜åˆ¶çƒï¼ˆå¸¦å‘å…‰æ•ˆæœï¼‰
      gameCtx.shadowColor = 'white';
      gameCtx.shadowBlur = 10;
      gameCtx.fillRect(ballX, ballY, ballSize, ballSize);
      gameCtx.shadowBlur = 0;
      
      // ç»˜åˆ¶ä¸­çº¿
      for (let i = 0; i < gameCanvas.height; i += 20) {
        gameCtx.fillRect(gameCanvas.width/2 - 1, i, 2, 10);
      }
      
      // ç»˜åˆ¶åˆ†æ•°ï¼ˆå¸¦å‘å…‰æ•ˆæœï¼‰
      gameCtx.font = "30px Arial";
      gameCtx.shadowColor = '#00ff88';
      gameCtx.shadowBlur = 5;
      gameCtx.fillText(`${leftScore} : ${rightScore}`, gameCanvas.width / 2 - 30, 40);
      gameCtx.shadowBlur = 0;
      
      // ç»˜åˆ¶ç²’å­
      particles.forEach(particle => particle.draw(gameCtx));
    }

    function resetBall() {
      ballX = gameCanvas.width / 2;
      ballY = gameCanvas.height / 2;
      ballDX = Math.sign(ballDX) * gameSpeed;
      ballDY = (Math.random() * 4) - 2;
    }

    gameLoop();
  }
  main();
</script>
</body>
</html>
